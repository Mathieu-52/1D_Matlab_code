% 1D two-phase solver + scalar and surfactant transport modeling
% Based on Mirjalili et al. JCP,2020, Mirjalili et al. IJHMT 2022,
% Mirjalili et al. CTR ARB 2022, and extending Teigen et al. CMS 2009 
% Second order finite differences in space
% Various explicit time stepping schemes
% Various options for mobility and phase field


clear all; close all;format long;


% Set desired plots to true, you can also change font_size, marker_size, and line_width here
my_plot=Plot_Setting(phi=true,srf=true,srf_os=false,srf_total=false,c1=true,c2=true,c_one_scalar=false,line_width=3);


% time stepping scheme
my_time_stepper=Set_Time_Stepping(use_euler=true);
[rk_order,pre_coeff,post_coeff]=my_time_stepper.params();

% Run settings: Only change if you want to do a series of runs while varying epsilon, gamma, mesh size, ...
my_run=Run_Setting();
my_run.set_loops();


% Simulation settings, including physical parameters
nx_base = 129;

% Euler dt (unnecessarily small if not using Euler time-stepping)
use_euler_dt = true;

% constant velocity
u = 0;

% free parameter determining speed of thermal/concentration equilibrium
Amp=1000;

centered = true; 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% TEST CASE %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Model options include CahnHilliard, conservativeDI. 
% Mobility options are Degenerate_1, Degenerate_2, Degenerate_3 
% and nonDegenerate
% BUT WE ONLY USE NONDEGENERATE MOBILITY 

my_pf=PF_Setting(model="conservativeDI", mobility="nonDegenerate");

%choice (1 = soluble in both and finite s_inf ;' ...
% 2 = realistic solubility in one phase (large diff ratio);' ...
% 3 = confined to one phase and interface;' ...
% 4 = interface confined; ' ...
% 5 = limit of s_inf=0 (not on interface), including fake interface ) 

choice = input("choice = " ); 




switch choice
    case 1 

            k_rat = 1;
            D1 = 1.0; D2 = 1.0; D_s = 0.2;
            c1_t0 = 1.0; c2_t0 = 1.0; srf_0 = 0.0;
            t_final = 2.1;
        
            r_a1 = 3; r_a2 = 1; r_d1 = 1;
            r_d2 = (r_d1 * r_a2) / (k_rat * r_a1);  
            s_inf = 1.0;



        
    case 2 
            k_rat = 1;
            D1 = 1.0; D2 = 0.25; D_s = 0.2;
            c1_t0 = 1.0; c2_t0 = 1.0; srf_0 = 0.0;
            t_final = 4.5;
        
            r_a1 = 3; r_a2 = 1; r_d1 = 1;
            r_d2 = (r_d1 * r_a2) / (k_rat * r_a1);  
            s_inf = 1.0;
        
    case 3 
        % choice phase 2 + interface 
            k_rat = 2;
            D1 = 0; D2 = 1.0; D_s = 0.2;
            c1_t0 = 0.0; c2_t0 = 2.0; srf_0 = 0.0;
            t_final = 3.0;
        
            r_a1 = 0.; r_a2 = 2; r_d1 = 0;
            r_d2 = 1;  
            s_inf = 1.0;
        
    case 4 
            k_rat = 2;
            D1 = 0.0; D2 = 0.0; D_s = 0.1;
            c1_t0 = 0.0; c2_t0 = 0.0; srf_0 = 0.5;
            t_final = 0.4;
        
            r_a1 = 0; r_a2 = 0; r_d1 = 0;
            r_d2 = 0;
            s_inf = 1.0;
        
    case 5 
            k_rat = 1;
            D1 = 1.0; D2 = 1.0; D_s = 0.0;
            c1_t0 = 1.0; c2_t0 = 1.0; srf_0 = 0.0;
            t_final = 0.8;   % enought to get equilibrium state 
        
            r_a1 = 2; r_a2 = 2; r_d1 = 1;
            r_d2 = (r_d1 * r_a2) / (k_rat * r_a1);  
            s_inf = 0.0;
        
    otherwise
                error('Invalid choice. Please enter 1, 2, 3, 4 or 5.');
end

          

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Henry's constant (c1/c2 across the interface at equilibrium)
HC1=1;
HC2=HC1/k_rat;

equilibrium_reached = false; 

error_5 = [];  % error for case 5 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% boundary conditions, default is periodic
dirichlet=0;
neumann=0;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




    % loop over resolutions
    for idx = 1:my_run.ndx
        
        % number of mesh cells
        nx = (nx_base-1)*2^(idx-1)+1;
        my_nx(idx) = nx;
        

        % mesh spacing
        dx = 2/(nx-1);
    
        % edge locations
        x_e = -1:dx:1;
        x_e=x_e';
        
        % cell center locations
        x_c=(x_e(2:end)+x_e(1:end-1))*0.5;
        
        gams = zeros(1,my_run.ngam+1); % all gamma values
        epss = zeros(my_run.neps+1,1); % all epsilon values

        
        
        % loop over gamma values
        for r = 1:my_run.ngam+1
            gam = u*((my_run.max_gam_u-my_run.min_gam_u)*(r-1)/my_run.ngam+my_run.min_gam_u);
            if my_run.single_run || my_run.eps_run
                gam =1.0; % default value for gamma
            end
            gams(r) = gam;
            
            % loop over epsilon values
            for q = 1:my_run.neps+1
                
                my_eps = dx*((my_run.max_eps_dx-my_run.min_eps_dx)*(q-1)/my_run.neps+my_run.min_eps_dx);
                if my_run.single_run || my_run.gam_run
                    if (my_pf.model == "CahnHilliard"||my_pf.model == "FloryHuggins")
                        my_eps = 2*dx;
                        my_pf.coeffMobility = (3*my_eps^2);%original
                        %coeffMobility = (3*my_eps);
                        %coeffMobility = 3;
                    else
                        my_eps = dx; % default value for epsilon (my_eps is used becaues eps is a constant in matlab)
                    end
                end
                epss(q) = my_eps;
                          
                D=Derivatives(nx-1,dx,dirichlet);


                
                % initial profile
                % phi = ((1/2*(1+tanh((x_c+0.25)/2/my_eps)) - 1/2*(1+tanh((x_c-0.25)/2/my_eps)))).*(abs(x_c)<0.25)+...
                %     ((1/2*(1+tanh((x_c+0.25)/2/(15*my_eps))) - 1/2*(1+tanh((x_c-0.25)/2/(5*my_eps))))).*(abs(x_c)>0.25);
                %phi=1/2*(1+tanh((x_c+.5)/2/my_eps));
                %phi=0.999;
                  %phi = ((1/2*(1+tanh((x_c+2.25)/2/my_eps)) - 1/2*(1+tanh((x_c-2.25)/2/my_eps))));
                phi = ((1/2*(1+tanh((x_c+.25)/2/my_eps)) - 1/2*(1+tanh((x_c-.25)/2/my_eps))));
                  % scalar field concentration in phase 1 per total volume
                c1 = 2*c1_t0.*phi.*exp(-(x_c./0.04).^2);
                c1_init = c1;
                
                % scalar field concentration in phase 2 per total volume
                c2 = c2_t0.*(1-phi);
                c2_init = c2;
                
                % total concentration
                c_tot =  c1+c2;
                c_tot_init = c_tot;
                c_one_scalar = c_tot; % we start the one scalar model with the c_tot
                c_one_scalar_i = c_tot;
    
                srf_init=srf_0.*Compute_Delta(phi,D);
                srf=srf_init;
                srf_os=srf_init+c1_init+c2_init;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

                c_total = dx*sum(c1_init + c2_init + srf_init);
                disp("value of c_total = " + c_total)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    

                % dt calculation       
                if ~use_euler_dt
                    if (my_time_stepper.use_rk2)
                        dt = my_run.cfactor*min(min(dx*dx/(2*gam*my_eps),sqrt(3)*dx/(u+gam)), dx*dx/(2*max(D1,D2))); %RK2
                    end
                    if (my_time_stepper.use_rk3)
                        dt = my_run.cfactor*min(min(2.51*dx*dx/(4*gam*my_eps),sqrt(3)*dx/(u+gam)),2.51*dx*dx/(4*max(D1,D2))); %RK3
                    end
                    if (my_time_stepper.use_rk4)
                        dt = my_run.cfactor*min(min(2.79*dx*dx/(4*gam*my_eps),2.83*dx/(u+gam)),2.79*dx*dx/4/max(D1,D2)); %RK4
                    end
                end
                
                if (my_pf.model == "CahnHilliard"||my_pf.model == "FloryHuggins")
                    dt = my_run.cfactor*(dx*dx);
                else 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                  
                    if choice == 4 
                        dt = 0.0001;  % I have to impose a dt in this case "interface confined"
                    else 
                        dt=my_run.cfactor*min(min(dx*dx/(2*gam*my_eps),1/(gam*my_eps/dx^2+(u+gam)^2/4/gam/my_eps)),dx*dx/2/max(D1,D2)); % euler
                    end 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                 
                end
                if (my_pf.model == "CahnHilliard")
                    dt=dt/5.0;%ad hoc penalty in time
                end
                
                if (my_run.one_step)
                    t_final = dt;
                end
                
                
                my_dt=dt/4
    
    
                time = 0.0;
                tic
                counter=1;
                is_final_time=false;
    
                
                while (time < t_final)
                    
                    % special treatment for the final time step
                    if (time+dt) > t_final
                        dt = t_final-time;
                        is_final_time=true;
                    end
                    
                    time = time + dt;
     
                     phi_int=phi;
                     c1_int=c1;
                     c2_int=c2;
                     c_one_scalar_int=c_one_scalar;
                     c_one_scalar_i_int=c_one_scalar_i;
                     srf_int=srf;
                     srf_os_int=srf_os;
                     
                     phi_np1=phi;
                     c1_np1=c1;
                     c2_np1=c2;
                     c_one_scalar_np1=c_one_scalar;
                     c_one_scalar_i_np1=c_one_scalar_i;
                     srf_np1=srf;
                     srf_os_np1=srf_os;

    
                    for rk_count=1:1:rk_order
                        [d_phi,S]= rk_step( phi_int, nx, u, dt, dx, gam, my_eps, dirichlet, neumann, my_pf, D);
                        d_c1=c1_rk_step( c1_int, c2_int, phi_int, S, srf_int, nx, u, dt, dx, D1, D2, my_eps, Amp, k_rat, dirichlet, neumann, my_pf, D, r_a1, r_a2, r_d1, r_d2, s_inf);
                        d_c2=c2_rk_step( c1_int, c2_int, phi_int, S, srf_int, nx, u, dt, dx, D1, D2, my_eps, Amp, k_rat, dirichlet, neumann, my_pf, D, r_a1, r_a2, r_d1, r_d2, s_inf);
                        d_c_one_scalar=c_one_scalar_rk_step( c_one_scalar_int, phi_int, S, nx, u, dt, dx, D1, D2, my_eps, k_rat, dirichlet, neumann, my_pf, D);
                        d_c_one_scalar_i=inc_c_one_scalar_rk_step( c_one_scalar_i_int, phi_int, S, nx, u, dt, dx, D1, D2, my_eps, k_rat, dirichlet, neumann, my_pf, D);
                        d_srf=srf_rk_step(srf_int, phi_int, S, c1_int, c2_int, nx, u, dt, dx, gam, my_eps, dirichlet, neumann, my_pf, D, D_s, r_a1, r_a2, r_d1, r_d2, s_inf);
                        d_srf_os=srf_one_scalar_rk_step(srf_os_int, phi_int, S, nx, u, dt, dx, D1, D2, my_eps, k_rat, dirichlet, neumann, my_pf, D, D_s, r_a1, r_a2, r_d1, r_d2, s_inf);
    
                        phi_int= phi + pre_coeff(rk_count)*d_phi;
                        c1_int= c1 + pre_coeff(rk_count)*d_c1;
                        c2_int= c2 + pre_coeff(rk_count)*d_c2;
                        c_one_scalar_int= c_one_scalar + pre_coeff(rk_count)*d_c_one_scalar;
                        c_one_scalar_i_int= c_one_scalar_i + pre_coeff(rk_count)*d_c_one_scalar_i;
                        srf_int= srf + pre_coeff(rk_count)*d_srf;
                        srf_os_int=srf_os + pre_coeff(rk_count)*d_srf_os;
    
                        phi_np1= phi_np1 + post_coeff(rk_count)*d_phi;
                        c1_np1= c1_np1 + post_coeff(rk_count)*d_c1;
                        c2_np1= c2_np1 + post_coeff(rk_count)*d_c2;
                        c_one_scalar_np1= c_one_scalar_np1 + post_coeff(rk_count)*d_c_one_scalar;
                        c_one_scalar_i_np1= c_one_scalar_i_np1 + post_coeff(rk_count)*d_c_one_scalar_i;   
                        srf_np1= srf_np1 + post_coeff(rk_count)*d_srf;
                        srf_os_np1= srf_os_np1 + post_coeff(rk_count)*d_srf_os;
                   end
                    
                     phi=phi_np1;
                     c1=c1_np1;
                     c2=c2_np1;
                     c_one_scalar=c_one_scalar_np1;
                     c_one_scalar_i=c_one_scalar_i_np1;
                     srf=srf_np1;
                     srf_os=srf_os_np1;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                      
                    tol = 1e-6;
       
                    mask = (phi > 1e-2) & (phi < 1 - 1e-2);  % avoid divisions by 0
                    

                    eq_diff = abs(c1_np1(mask)./phi(mask) - k_rat * c2_np1(mask)./(1 - phi(mask)));
                    
                    max_err = max(eq_diff);
                    
                    if max_err < tol
                        disp("Equilibrium satisfied --------------- YESSSSSSSSSSS")
                        disp("time  = "+ time)   % to get a precise final time ( = equilibrium state )
                    else
                        disp("Equilibrium not satisfied")
                        continue  
                    end

                      




% error 

                    error_5(end+1) = norm((c_one_scalar - (c1 + c2)), inf);
                               
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                    T=c_one_scalar./(HC1*phi+HC2*(1-phi));
                    T_i=c_one_scalar_i./(HC1*phi+HC2*(1-phi));
                    T_1=(c1+c2)./(HC1*phi+HC2*(1-phi));%(HC1*phi);
                    T_2=c2./(HC2*(1-phi));
        
                    % plotting evolution of data
              
                    if((mod(counter,my_plot.plotting_frequency)==1)||(is_final_time))
                        my_plotter(x_c,phi,c1,c2,c_one_scalar,c_one_scalar_i,srf,srf_os,T,T_i,T_1,T_2,my_plot);
                        pause(0.1)
                        hold on
                        %plot(x_c,1*(c1_t0*phi-c1),'-.k','linewidth',2);
                        hold off
                        %               saveas(gcf,sprintf('image_vor_%d',counter),'fig')
                        %               set(gcf,'PaperUnits','inches','PaperPosition',[0 0 16 12]);
                        %     print(gcf,'-depsc','-r100',sprintf('image_%d',counter));
                        
                        xlabel('$x$','interpreter','latex','fontsize',my_plot.font_size);
                        set(gca,'Fontsize',my_plot.font_size)
                        pause(0.01)
                        hold off
                        time_percent=100*time/t_final;
                        total=sum(c1+c2+srf);
                        total_os=sum(srf_os);
                    end
                    counter=counter+1;




                end
                
                
                 toc
                
            end
        end

    end







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% Validation Test  %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% MASS CONSERVATION (validate for 1 & 3 scalars model)
mass_init  =  dx*sum(c1_init + c2_init + srf_init);
mass_final = dx*sum(c1_np1 + c2_np1 + srf_np1);


            
if abs(mass_init - mass_final) < 1e-6 % machin accuracy  
    disp("Test " + choice + " validated -> total mass conserved globally");
else
    disp("!!!!!!! Test "  + choice + " Invalid -> mass not conserved !!!!!!!!");
end




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% construction of the function from data
xq = linspace(min(x_c), max(x_c), 1000);
f_phi = @(xq) interp1(x_c, phi, xq, 'linear' , 'extrap');  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Verification : if the curves of f_phi and phi are stacked in the x domain

%figure;
%set(gcf, 'Color', 'w');  % Fond blanc de la figure
%plot(x_c, f_phi(x_c), 'r-x', 'LineWidth', 2);
%hold on;
%plot(x_c, phi, 'b-x', 'LineWidth', 2);
%hold off;

%xlabel('x');
%ylabel('phi');
%legend('Phi function', 'Phi vector');
%title('Curves of phi function and vector');
%grid on;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%  Integral of f_phi in the x domain [-1;1]   %%%%%%%%%%%%%     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


I1 = sum(phi)*dx;
I2 = sum(Compute_Delta(phi,D))*dx;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%    Calcul of the cst c_total    %%%%%%%%%%%%%     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%c_total = dx*sum(c1_np1 + c2_np1 + srf_np1);
%c_total = (c1_t0+c2_t0+srf_0);
%c_total = 1.4;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%    Calcul of c2 analytical     %%%%%%%%%%%%%     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if (choice ~= 4 )
    c2_ana_tilde = c2_analytical(r_a2,r_d2,c_total,s_inf,k_rat,I1,I2); 
    
    c2_ana = c2_ana_tilde*(1-phi); 
    
    figure;
    plot(x_c, c2_np1, 'r-x', 'LineWidth', 2);
    hold on;
    plot(x_c, c2_ana, 'b-o', 'LineWidth', 2);
    hold off;
    
    xlabel('x');
    ylabel('c');
    legend('c2','c2 ana');
    title('Numerical and analytical c2 results at equilibrium');
    grid on;
else 
    c2_ana_tilde = 0;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%    Calcul of S analytical     %%%%%%%%%%%%%     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% using delta = 6phi(1-phi)
if ~ismember(choice, [4 5])
    S_tilde_ana = ((r_a2*s_inf*c2_ana_tilde)/(r_d2+r_a2*c2_ana_tilde));
    S_ana = S_tilde_ana*6*phi.*(1-phi); 
    
    figure;
    plot(x_c, srf_np1  , 'r-x', 'LineWidth', 2);
    hold on;
    plot(x_c, S_ana, 'b-o', 'LineWidth', 2);
    hold off;

    
    xlabel('x');
    ylabel('S');
    legend('S','S ana');
    title('Numerical and analytical S results at equilibrium');
    grid on;
elseif (choice == 4)
    S_ana = srf_0.*Compute_Delta(phi,D);
    
    figure;
    plot(x_c, srf_np1  , 'r-x', 'LineWidth', 2);
    hold on;
    plot(x_c, S_ana, 'b-o', 'LineWidth', 2);
    hold off;

    
    xlabel('x');
    ylabel('S');
    legend('S','S ana');
    title('Numerical and analytical S results at equilibrium');
    grid on;
end 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%    Calcul of c1 analytical     %%%%%%%%%%%%%     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~ismember(choice, [3 4])
    c1_ana = c2_ana_tilde*k_rat*phi;
    
    figure;
    plot(x_c, c1_np1  , 'r-x', 'LineWidth', 2);
    hold on;
    plot(x_c, c1_ana, 'b-o', 'LineWidth', 2);
    hold off;
    
    xlabel('x');
    ylabel('c');
    legend('c1','c1 ana');
    title('Numerical and analytical c1 results at equilibrium');
    grid on;
end 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% TEST PRCQ CA MARCHE PAS PTN %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%disp("c2 tilde num = " + c2_np1./(1-phi))
%disp("                                    ")
%disp("c2 tilde ana = " + c2_ana_tilde)

%disp("                                    ")
%disp("S tilde num = " + srf_np1./(6*phi.*(1-phi)))
%disp("                                    ")
%disp("S tilde ana = " + S_tilde_ana)

%disp("                                    ")
%disp("c1 tilde num = " + c1_np1./phi)
%disp("                                    ")
%disp("c1 tilde ana = " + c2_ana_tilde*k_rat)


%disp("                                    ")
%disp("value of sum c_init= " + (c1_t0+c2_t0+srf_0))


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%      ERROR        %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



if (choice == 5)
    figure;
    plot(x_c, c1_np1 + c2_np1 , 'r-x', 'LineWidth', 2); hold on;
    plot(x_c, c_one_scalar_np1, 'g-o', 'LineWidth', 1, 'MarkerIndices', 1:10:length(x_c));
    xlabel('x'); ylabel('c');
    legend('c1 + c2','c one scalar');
    title('Fake interface test');
    grid on;
    drawnow;
    pause(0.1)
 
% courbe d'erreur 
    figure;
    semilogy(error_5, 'r-o');
    xlabel('Time step');
    ylabel('Relative error (∞-norm)');
    title('Error between c\_one\_scalar and c1 + c2');
    grid on;
else
    error_c1 = norm((c1_np1 - c1_ana), inf);
    error_c2 = norm((c2_np1 - c2_ana), inf);
    error_S = norm((srf_np1 - S_ana), inf);

    disp(" Error c1 = " + error_c1)
    disp(" Error c1 = " + error_c1)



end 

